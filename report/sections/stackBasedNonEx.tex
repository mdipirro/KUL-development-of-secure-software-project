\section{Stack-Based Buffer Overflow with Non-Executable Stack} \label{sec:nonEx}
\subsection{Casper8}
\subsubsection{Description and vulnerability}
Casper8's behavior is the same as Casper4 (see Section~\ref{sec:casper4}). It takes a command-line parameter and calls \texttt{greetUser}. The latter declares a 666-characters long buffer and copies the user-provided parameter in it. Afterwards, it prints \textit{Hello} followed by the buffer content. If the parameter is not provided, an error message is shown.

This implies that the vulnerability is the same, and, as for Casper4, it relies on the use of the unsafe C's \texttt{strcpy} function. Nevertheless, Casper8 is protected by a non-executable stack. This means that the simple exploit described in Section~\ref{sec:casper4} does not work, since a direct code injection is not possible anymore. In order to exploit the program, an indirect code injection is needed. Since stack canaries are disabled, it is still possible to overflow the buffer and overwrite the return address.

\subsubsection{Exploit}
The exploit for Casper8 works as follows:
\begin{enumerate}
	\item Add an environment variable containing the string ``/bin/xh'', which corresponds to the command we aim to execute (its name is \textbf{EVIL});
	\item Insert in the buffer some random characters to overflow it (these bytes should fill in the entire buffer and the space between its ending and the return address);
	\item Overwrite the return address making it point to the C's library \texttt{system} function;
	\item Provide a fake stack frame for the \texttt{system} execution. This involves:
	\begin{enumerate}
		\item Provide a return address. This would allow the exploit to execute more functions in a chain. In this exploit this address is set to the address of the C's \texttt{exit} function, so that the programs exits normally and without any errors.
		\item Provide a parameter for \texttt{system}. This parameter will be the address of the environment variable containing ``/bin/xh''. When \texttt{system} starts to execute, it follows this pointer, finds the string and executes the command \texttt{/bin/xh}.
	\end{enumerate}
\end{enumerate}
This exploits involves a more complex debugging and address-discovery procedure, since it uses environment variables. These variables have different addresses depending on the running program (and its name's length). This is why the exploit first uses a C program, \texttt{find\_env}, to predict the EVIL's address and then pass this information to a Python script which takes case of generating the actual exploitation string.

The code for the C program is taken by the book \textit{Hacking: The Art of Exploitation} by Jon Erickson. As a matter of fact, the name of the program is stored in an environment variable (named ``\_'') and pushed on the stack before all the other environment variables. This means that the address of the environment variable decreases of two bytes for every single-byte increase in the length of the program name. This is the meaning of the following operation: \texttt{(strlen(argv[0]) - strlen(argv[2]))*2;}.

After having obtained a precise prediction of the EVIL address, a Python script takes care of printing it in the right way. First of all it takes a parameter from the command line (put there by \texttt{find\_env}) and removes the first two characters ($0x$). Then it composes the address backward, simulating a little endian machine. For each pair of bytes, it extracts the hexadecimal representation and appends it to a string. The process of converting the string in a hexadecimal number and then back in a character representation is basically what is done under the hood prepending \texttt{$\backslash$x} in the \texttt{print} command. After that, it simply print a string to exploit Casper8. This string is composed as explained below.

The first step is to find out how many bytes the exploit should fill in to reach the return address:
\begin{itemize}
	\item Buffer beginning address: \texttt{0xbffff0c6}
	\item Local variables beginning address: \texttt{0xbffff368}
	\item Address of the return pointer: \texttt{0xbffff36c}
\end{itemize}
The number of bytes is given by:
\begin{center}
	\texttt{address\_return\_pointer} - \texttt{address\_buffer} =\\
	= \texttt{0xbffff36c} - \texttt{0xbffff0c6} = 678
\end{center}

The second step is to find out the addresses of \texttt{system} and \texttt{exit}. They are statically linked, and their addresses do not change (or better, it changes depending on Casper8 is executed starting from a \texttt{Makefile} or not). A simple debug on the core dump generated by a crashing execution of Casper8 reveals the following addresses:
\begin{itemize}
	\item \texttt{system}: \texttt{0x4006b310}
	\item \texttt{exit}: \texttt{0x4005e260}
\end{itemize}

Finally, the exploit string is built as follows:
\begin{itemize}
	\item 678 characters to fill in the buffer (``f'');
	\item \texttt{system} address (\texttt{0x4006b310});
	\item \texttt{exit} address (\texttt{0x4005e260});
	\item EVIL address.
\end{itemize}

In order to run the exploit it is enough to run \texttt{make exploit8}.

\subsubsection{Possible countermeasures}
An effective countermeasure against this exploit would be cleaning the environment variables before copying the parameter into the buffer. This is what Casper81 does, and in this case it is necessary to scan the memory looking for the string ``/bin/xh'' to run the exploit, instead of hard-code it in an environment variable.

Another effective countermeasure in this case is stack canaries. The exploit still overflows the buffer and fills in the memory until the return address, and this is something a stack canary can easily detect. Control-flow enforcement and stack layout randomization are other possibilities. The former can detect an unexpected change in the return address, while the latter can make it more difficult to figure out the correct addresses.

Again, using a secure version of \texttt{strcpy} would cut the exploit off.

\subsection{Casper80}
The exploit for Casper80 is exactly the same used for Casper8. The defense put in place, looking for NOP bytes, is completely useless since they are not part of the exploit. The only difference relies on the number of bytes to fill in to reach the return address. Since the function \texttt{greetUser} declares a pointer after the buffer, it is necessary to count 4 bytes more. In fact, the following are the addresses found out with \texttt{gdb}:
\begin{itemize}
	\item Buffer beginning address: \texttt{0xbffff0b2}
	\item Local variables beginning address: \texttt{0xbffff358}
	\item Address of the return pointer: \texttt{0xbffff35c}
\end{itemize}
The number of bytes is given by:
\begin{center}
	\texttt{address\_return\_pointer} - \texttt{address\_buffer} =\\
	= \texttt{0xbffff35c} - \texttt{0xbffff0b2} = 682
\end{center}


In order to run the exploit it is enough to run \texttt{make exploit80}.