\section{Stack-Based Buffer Overflow with Non-Executable Stack} \label{sec:nonEx}
\subsection{Casper8}
\subsubsection{Description and vulnerability}
Casper8's behavior is the same as Casper4 (see Section~\ref{sec:casper4}). It takes a command-line parameter and calls \texttt{greetUser}. The latter declares a 666-characters long buffer and copies the user-provided parameter in it. Afterwards, it prints \textit{Hello} followed by the buffer content. If the parameter is not provided, an error message is shown.

This implies that the vulnerability is the same, and, as for Casper4, it relies on the use of the unsafe C's \texttt{strcpy} function. Nevertheless, Casper8 is protected by a non-executable stack. This means that the simple exploit described in Section~\ref{sec:casper4} does not work, since a direct code injection is not possible anymore. In order to exploit the program, an indirect code injection is needed. Since stack canaries are disabled, it is still possible to overflow the buffer and overwrite the return address without being detected.

\subsubsection{Exploit}
The exploit for Casper8 works as follows:
\begin{enumerate}
	\item Add an environment variable containing the string \textit{``/bin/xh''}, which corresponds to the command we aim to execute (its name is \textbf{EVIL});
	\item Insert in the buffer some random characters to overflow it (these bytes should fill in the entire buffer and the space between its ending and the return address);
	\item Overwrite the return address making it point to the C's library \texttt{system} function;
	\item Provide a fake stack frame for the \texttt{system} execution. This involves:
	\begin{enumerate}
		\item Provide a return address. This would allow the exploit to execute more functions in a chain. In this exploit this address is set to the address of the C's \texttt{exit} function, so that the programs exits normally and without any errors.
		\item Provide a parameter for \texttt{system}. This parameter will be the address of the environment variable containing ``/bin/xh''. When \texttt{system} starts to execute, it follows this pointer, finds the string and executes the command \texttt{/bin/xh}.
	\end{enumerate}
\end{enumerate}
The first idea I had to exploit Casper8 was to detect the exact EVIL's address using a C program. In general, environment variables have different addresses depending on the running program (and its name's length).  As a matter of fact, the name of the program is stored in an environment variable (named ``\_'') and pushed onto the stack before all the other environment variables. The address of the environment variable decreases of two bytes for every single-byte increase in the length of the program name. 

However, the exploit is run by mean of a \texttt{Makefile}, and this makes the environment change in different ways. This is the reason why I debugged Casper8 in order to establish a reasonable \textit{address range} in which EVIL may vary. This produced the following partial address: \texttt{0xbffff8\_\_}, where the last byte changes. Thus, a small bash loop tries every possible value from \texttt{01} to \texttt{ff}. 

The final exploit's string is composed as explained below.

The first step is to find out how many bytes the exploit should fill in to reach the return address:
\begin{itemize}
	\item Buffer beginning address: \texttt{0xbffff0c6}
	\item Local variables beginning address: \texttt{0xbffff368}
	\item Address of the return pointer: \texttt{0xbffff36c}
\end{itemize}
The number of bytes is given by:
\begin{center}
	\texttt{address\_return\_pointer} - \texttt{address\_buffer} =\\
	= \texttt{0xbffff36c} - \texttt{0xbffff0c6} = 678
\end{center}

The second step is to find out the addresses of \texttt{system} and \texttt{exit}. They are statically linked, and their addresses do not change (or better, they change depending on Casper8 is executed starting from a \texttt{Makefile} or not). A simple debug on the core dump generated by a crashing execution of Casper8 reveals the following addresses:
\begin{itemize}
	\item \texttt{system}: \texttt{0x4006b310}
	\item \texttt{exit}: \texttt{0x4005e260}
\end{itemize}

Finally, the exploit string is built as follows:
\begin{itemize}
	\item 678 characters to fill in the buffer (``f'');
	\item \texttt{system} address (\texttt{0x4006b310});
	\item \texttt{exit} address (\texttt{0x4005e260});
	\item EVIL address.
\end{itemize}

In order to run the exploit it is enough to run \texttt{make exploit8}.

\subsubsection{Possible countermeasures}
An effective countermeasure against this exploit would be cleaning the environment variables before copying the parameter into the buffer. This is what Casper81 does, and in this case it is necessary to scan the memory looking for the string ``/bin/xh'' to run the exploit, instead of hard-code it in an environment variable.

Another effective countermeasure in this case is stack canaries. The exploit still overflows the buffer and fills in the memory until the return address, and this is something a stack canary can easily detect. Control-flow enforcement and stack layout randomization are other possibilities. The former can detect an unexpected change in the return address, while the latter can make it more difficult to figure out the correct addresses.

Again, using a secure version of \texttt{strcpy} would cut the exploit off.

\subsection{Casper80}
The exploit for Casper80 is exactly the same used for Casper8. The defense put in place, looking for NOP bytes, is completely useless since they are not part of the exploit. The only difference relies on the number of bytes to fill in to reach the return address. Since the function \texttt{greetUser} declares a pointer after the buffer, it is necessary to count 4 bytes more. In fact, the following are the addresses found out with \texttt{gdb}:
\begin{itemize}
	\item Buffer beginning address: \texttt{0xbffff0b2}
	\item Local variables beginning address: \texttt{0xbffff358}
	\item Address of the return pointer: \texttt{0xbffff35c}
\end{itemize}
The number of bytes is given by:
\begin{center}
	\texttt{address\_return\_pointer} - \texttt{address\_buffer} =\\
	= \texttt{0xbffff35c} - \texttt{0xbffff0b2} = 682
\end{center}


In order to run the exploit it is enough to run \texttt{make exploit80}.
